---
title: PAT (Basic Level) Practice
date: 2020-02-19 10:48:29
tags: 'C语言基础编程'
categories: 'C语言'
mathjax: true
---

> PAT冲鸭
> 题库：PAT (Basic Level) Practice （中文）

### 1001 害死人不偿命的(3n+1)猜想 (15分)

> 卡拉兹(Callatz)猜想：
>
> 对任何一个正整数 *n*，如果它是偶数，那么把它砍掉一半；如果它是奇数，那么把 (3*n*+1) 砍掉一半。这样一直反复砍下去，最后一定在某一步得到 *n*=1。卡拉兹在 1950 年的世界数学家大会上公布了这个猜想，传说当时耶鲁大学师生齐动员，拼命想证明这个貌似很傻很天真的命题，结果闹得学生们无心学业，一心只证 (3*n*+1)，以至于有人说这是一个阴谋，卡拉兹是在蓄意延缓美国数学界教学与科研的进展……
>
> 我们今天的题目不是证明卡拉兹猜想，而是对给定的任一不超过 1000 的正整数 *n*，简单地数一下，需要多少步（砍几下）才能得到 *n*=1？
>
> ### 输入格式：
>
> 每个测试输入包含 1 个测试用例，即给出正整数 *n* 的值。
>
> ### 输出格式：
>
> 输出从 *n* 计算到 1 需要的步数。
>
> ### 输入样例：
>
> ```in
> 3
> ```
>    
>    ### 输出样例：
> 
>```out
> 5
>```

#### 解题思路

主要把结果统计输出即可。

#### 提交代码

```c
#include <stdio.h>
int main() {
	int n;
	int count = 0;
	scanf("%d",&n);
	while(n!=1)
	{
		if (n % 2 != 0) {
			n = (3 * n + 1) / 2;
		}
		else {
			n /=2;
		}
		count++;
	}
	printf("%d", count);
	return 0;
}
```

#### 总结

难度1星

----

### 1002 写出这个数 (20分)

>读入一个正整数 *n*，计算其各位数字之和，用汉语拼音写出和的每一位数字。
>
>### 输入格式：
>
>每个测试输入包含 1 个测试用例，即给出自然数 *n* 的值。这里保证 *n* 小于 10<sup>100</sup>。
>
>### 输出格式：
>
>在一行内输出 *n* 的各位数字之和的每一位，拼音数字间有 1 空格，但一行中最后一个拼音数字后没有空格。
>
>### 输入样例：
>
>```in
>1234567890987654321123456789
>```
>
>### 输出样例：
>
>```out
>yi san wu
>```

#### 解题思路

首先是接收数据，然后是关于位数的计算问题，再中文拼音转换。

#### 提交代码

```c
#include <stdio.h>
void outcome(int n);
int main() {
	int nums[100];
	int sum = 0;
	int n;
	int i=0;
	while ((n=getchar())!='\n')
	{
		n -= 48;
		sum += n;
	}
	while (sum != 0) {
		nums[i] = sum % 10;
		sum /= 10;
		i++;
	}
	for (int j = i-1; j>=0; j--)
	{
		if (j!=i-1)
		{
			printf(" ");
		}
		outcome(nums[j]);
		
	}
    return 0;  
}
void outcome(int n) {
	switch (n)
	{
	case 0:printf("ling"); break;
	case 1:printf("yi"); break;
	case 2:printf("er"); break;
	case 3:printf("san"); break;
	case 4:printf("si"); break;
	case 5:printf("wu"); break;
	case 6:printf("liu"); break;
	case 7:printf("qi"); break;
	case 8:printf("ba"); break;
	case 9:printf("jiu"); break;
	default:
		break;
	}
}

```

#### 总结

整体不是很难

----

### 1003 我要通过！ (20分)

>“**答案正确**”是自动判题系统给出的最令人欢喜的回复。本题属于 PAT 的“**答案正确**”大派送 —— 只要读入的字符串满足下列条件，系统就输出“**答案正确**”，否则输出“**答案错误**”。
>
>得到“**答案正确**”的条件是：
>
>1. 字符串中必须仅有 `P`、 `A`、 `T`这三种字符，不可以包含其它字符；
>2. 任意形如 `xPATx` 的字符串都可以获得“**答案正确**”，其中 `x` 或者是空字符串，或者是仅由字母 `A` 组成的字符串；
>3. 如果 `aPbTc` 是正确的，那么 `aPbATca` 也是正确的，其中 `a`、 `b`、 `c` 均或者是空字符串，或者是仅由字母 `A` 组成的字符串。
>
>现在就请你为 PAT 写一个自动裁判程序，判定哪些字符串是可以获得“**答案正确**”的。
>
>### 输入格式：
>
>每个测试输入包含 1 个测试用例。第 1 行给出一个正整数 *n* (<10)，是需要检测的字符串个数。接下来每个字符串占一行，字符串长度不超过 100，且不包含空格。
>
>### 输出格式：
>
>每个字符串的检测结果占一行，如果该字符串可以获得“**答案正确**”，则输出 `YES`，否则输出 `NO`。
>
>### 输入样例：
>
>```in
>8
>PAT
>PAAT
>AAPATAA
>AAPAATAAAA
>xPATx
>PT
>Whatever
>APAAATAA
>```
>
>### 输出样例：
>
>```out
>YES
>YES
>YES
>YES
>NO
>NO
>NO
>NO
>```

#### 解题思路

https://blog.csdn.net/oShuaiFeng/article/details/80622269

#### 提交代码

```c
#include <stdio.h>
#define N 10
#define L 100
void yesOrNo(char str[L]);
int main() {

	int count;
	char str[N][L];
	scanf("%d", &count);
	for (int i = 0; i < count; i++)
	{
		scanf("%s", &str[i]);
		yesOrNo(str[i]);
	}
	return 0;
}

void yesOrNo(char str[L]) {
	//1.只有PAT三个字符
	int flag = 1;
	int p=0, t = 0, a=0;
	int aqnum = 0, aznum = 0, ahnum = 0;
	int locate = 0;
	int i = 0;
	while (str[i]!='\0')
	{
		if (str[i] == 'P') {
			p++;
			locate = 1;
			flag = 0;
		}
		else if (str[i] == 'T') {
			t++;
			locate = 2;
			flag = 0;
		}
		else if (str[i] == 'A') {
			a++;
			flag = 0;
		}
		else flag = 1;
		switch (locate)
		{
		case 0:aqnum++; break;
		case 1:if (str[i]!= 'P')aznum++; break;
		case 2:if (str[i]!= 'T')ahnum++; break;
		default:
			break;
		}
		i++;
	}
		
	if (flag==0 && aqnum*aznum==ahnum && p==1 && t==1 &&a>=1)
	{
		printf("YES\n");
	}
	else {
		printf("NO\n");
	}
}

```

#### 总结

这一题主要难在看懂题意

----

### 1004 成绩排名 (20分)

>读入 *n*（>0）名学生的姓名、学号、成绩，分别输出成绩最高和成绩最低学生的姓名和学号。
>
>### 输入格式：
>
>每个测试输入包含 1 个测试用例，格式为
>
>```
>第 1 行：正整数 n
>第 2 行：第 1 个学生的姓名 学号 成绩
>第 3 行：第 2 个学生的姓名 学号 成绩
>  ... ... ...
>第 n+1 行：第 n 个学生的姓名 学号 成绩
>
>      
>    
>```
>
>其中`姓名`和`学号`均为不超过 10 个字符的字符串，成绩为 0 到 100 之间的一个整数，这里保证在一组测试用例中没有两个学生的成绩是相同的。
>
>### 输出格式：
>
>对每个测试用例输出 2 行，第 1 行是成绩最高学生的姓名和学号，第 2 行是成绩最低学生的姓名和学号，字符串间有 1 空格。
>
>### 输入样例：
>
>```in
>3
>Joe Math990112 89
>Mike CS991301 100
>Mary EE990830 95
>```
>
>### 输出样例：
>
>```out
>Mike CS991301
>Joe Math990112
>```

#### 解题思路

结构体来做

#### 提交代码

```c
#include <stdio.h>
#define N 1000
typedef struct Students
{
	char name[11];
	char id[11];
	int  result;
}Student;

int main() {
	
	int count;
	int i;
	int max=0;
	int min=0;
	scanf("%d",&count);
	Student student[N];

	for (i = 0; i < count; i++)
	{
		scanf("%s %s %d", &student[i].name, &student[i].id, &student[i].result);
	}
	
	for (i = 0; i < count; i++)
	{
		if (student[max].result< student[i].result)max = i;
		if (student[min].result> student[i].result)min = i;
	}
	printf("%s %s\n", student[max].name, student[max].id);
	printf("%s %s", student[min].name, student[min].id);
	return 0;
}
```

#### 总结

数组的范围很重要，还有常量的范围1000是我第三个通过点一直不过的原因。

----

### 1005 继续(3n+1)猜想 (25分)

>卡拉兹(Callatz)猜想已经在1001中给出了描述。在这个题目里，情况稍微有些复杂。
>
>当我们验证卡拉兹猜想的时候，为了避免重复计算，可以记录下递推过程中遇到的每一个数。例如对 *n*=3 进行验证的时候，我们需要计算 3、5、8、4、2、1，则当我们对 *n*=5、8、4、2 进行验证的时候，就可以直接判定卡拉兹猜想的真伪，而不需要重复计算，因为这 4 个数已经在验证3的时候遇到过了，我们称 5、8、4、2 是被 3“覆盖”的数。我们称一个数列中的某个数 *n* 为“关键数”，如果 *n* 不能被数列中的其他数字所覆盖。
>
>现在给定一系列待验证的数字，我们只需要验证其中的几个关键数，就可以不必再重复验证余下的数字。你的任务就是找出这些关键数字，并按从大到小的顺序输出它们。
>
>### 输入格式：
>
>每个测试输入包含 1 个测试用例，第 1 行给出一个正整数 *K* (<100)，第 2 行给出 *K* 个互不相同的待验证的正整数 *n* (1<*n*≤100)的值，数字间用空格隔开。
>
>### 输出格式：
>
>每个测试用例的输出占一行，按从大到小的顺序输出关键数字。数字间用 1 个空格隔开，但一行中最后一个数字后没有空格。
>
>### 输入样例：
>
>```in
>6
>3 5 6 7 8 11    
>```
>
>### 输出样例：
>
>```out
>7 6
>```

#### 解题思路



#### 提交代码

```c

```

#### 总结
----

### 1006 换个格式输出整数 (15分)

>让我们用字母 `B` 来表示“百”、字母 `S` 表示“十”，用 `12...n` 来表示不为零的个位数字 `n`（<10），换个格式来输出任一个不超过 3 位的正整数。例如 `234` 应该被输出为 `BBSSS1234`，因为它有 2 个“百”、3 个“十”、以及个位的 4。
>
>### 输入格式：
>
>每个测试输入包含 1 个测试用例，给出正整数 *n*（<1000）。
>
>### 输出格式：
>
>每个测试用例的输出占一行，用规定的格式输出 *n*。
>
>### 输入样例 1：
>
>```in
>234   
>```
>
>### 输出样例 1：
>
>```out
>BBSSS1234    
>```
>
>### 输入样例 2：
>
>```in
>23  
>```
>
>### 输出样例 2：
>
>```out
>SS123
>```

#### 解题思路



#### 提交代码

```c
#include <stdio.h>

int main() {
	int n;
	int bai;
	int shi;
	int ge;
	int i;
	scanf("%d",&n);
	ge = n % 10;
	shi = n / 10 %10;
	bai = n / 10 /10;
	for (i = 0; i < bai; i++)
	{
		printf("B");
	}
	for (i = 0; i < shi; i++)
	{
		printf("S");
	}
	for (i = 1; i <= ge; i++)
	{
		printf("%d",i);
	}
	return 0;
}
```

#### 总结

难度0.5星

----

### 1007 素数对猜想 (20分)

>让我们定义$d_{n}$为：$d_{n}=p_{n+1}-p_{n}$，其中$p_{i}$是第$i$个素数。显然有$d_{1}=1$，且对于$n>1$有$d_{n}$是偶数。“素数对猜想”认为“存在无穷多对相邻且差为2的素数”。
>
>现给定任意正整数`N`(<105)，请计算不超过`N`的满足猜想的素数对的个数。
>
>### 输入格式:
>
>输入在一行给出正整数`N`。
>
>### 输出格式:
>
>在一行中输出不超过`N`的满足猜想的素数对的个数。
>
>### 输入样例:
>
>```in
>20    
>```
>
>### 输出样例:
>
>```out
>4
>```

#### 解题思路

首先先判断素数，然后将符合公式的素数计数即可。

#### 提交代码

```c
#include <stdio.h>

int main() {
	int n;
	int i, j;
	int count=0;
	scanf("%d",&n);
	for (i = 2; i <= n-2; i++)
	{
		if (isPrime(i)&& isPrime(i+2)) {
			count++;
		}
	}
	printf("%d", count);
	return 0;
}
int isPrime(int i) {
	int flag = 1;
	int j;
	for (j = 2; j * j <= i; j++)
	{
		if (i % j == 0) {
			flag = 0;
		}
	}
	return flag;

}
```

#### 总结



----

### 1008 数组元素循环右移问题 (20分)

>一个数组*A*中存有$N(>0)$个整数，在不允许使用另外数组的前提下，将每个整数循环向右移$M(\geq 0)$个位置，即将*A*中的数据由$\left(A_{0} A_{1} \cdots A_{N-1}\right)$变换为$\left(A_{N-M} \cdots A_{N-1} A_{0} A_{1} \cdots A_{N-M-1}\right)$（最后*M*个数循环移至最前面的$M$个位置）。如果需要考虑程序移动数据的次数尽量少，要如何设计移动的方法？
>
>### 输入格式:
>
>每个输入包含一个测试用例，第1行输入$N(1≤N≤100)$和$M(≥0)$；第2行输入$N$个整数，之间用空格分隔。
>
>### 输出格式:
>
>在一行中输出循环右移*M*位以后的整数序列，之间用空格分隔，序列结尾不能有多余空格。
>
>### 输入样例:
>
>```in
>6 2
>1 2 3 4 5 6  
>```
>
>### 输出样例:
>
>```out
>5 6 1 2 3 4
>```

#### 解题思路

https://blog.csdn.net/u011703187/article/details/89105618

#### 提交代码

```c
#include <stdio.h>

int main() {
	int n, m;
	int i,t;
	int nums[101];
	scanf("%d %d", &n, &m);
	m = m % n;
	for (i = 0; i < n; i++)
	{
		scanf("%d", &nums[i]);
	}
	for (i = n - m; i < n ; i++)printf("%d ", nums[i]);
	for (i = 0; i < n-m-1; i++)printf("%d ", nums[i]);
	printf("%d", nums[n-m-1]);
	return 0;
}
```

#### 总结
----

### 1009 说反话 (20分)

>给定一句英语，要求你编写程序，将句中所有单词的顺序颠倒输出。
>
>### 输入格式：
>
>测试输入包含一个测试用例，在一行内给出总长度不超过 80 的字符串。字符串由若干单词和若干空格组成，其中单词是由英文字母（大小写有区分）组成的字符串，单词之间用 1 个空格分开，输入保证句子末尾没有多余的空格。
>
>### 输出格式：
>
>每个测试用例的输出占一行，输出倒序后的句子。
>
>### 输入样例：
>
>```in
>Hello World Here I Come    
>```
>
>### 输出样例：
>
>```out
>Come I Here World Hello
>```

#### 解题思路



#### 提交代码

```c
#include <stdio.h>
#include <string.h>
int main() {
	int i,j;
	char str[81];
	int strlength;
	gets(str);
	strlength=strlen(str);
	
	for (i = strlength-1; i >=0; i--)
	{
		if (str[i] == ' ') {
			j = i + 1;
			do
			{
				printf("%c", str[j]);
				j++;
			} while (str[j]!=' '&& str[j] != '\0');
			printf(" ");
		}
	}
	j = 0;
	do
	{
		printf("%c", str[j]);
		j++;
	} while (str[j] != ' ' && str[j] != '\0');
	
	return 0;
}

```

#### 总结
----

### 1010 一元多项式求导 (25分)

>设计函数求一元多项式的导数。（注：$x^{n}$（$n$为整数）的一阶导数为$n x^{n-1}$。）
>
>### 输入格式:
>
>以指数递降方式输入多项式非零项系数和指数（绝对值均为不超过 1000 的整数）。数字间以空格分隔。
>
>### 输出格式:
>
>以与输入相同的格式输出导数多项式非零项的系数和指数。数字间以空格分隔，但结尾不能有多余空格。注意“零多项式”的指数和系数都是 0，但是表示为 `0 0`。
>
>### 输入样例:
>
>```in
>3 4 -5 2 6 1 -2 0 
>```
>
>### 输出样例:
>
>```out
>12 3 -10 1 6 0
>```

#### 解题思路

https://blog.csdn.net/qq_43444398/article/details/89223396

#### 提交代码

```c
#include <stdio.h>
#include <string.h>
int main() {
	int a, b;
	scanf("%d %d", &a, &b);
	if (b==0)
	{
		printf("0 0");
		return 0;
	}
	else if (b != 0) { 
		printf("%d %d", a * b, b - 1); 
	}
	while (scanf("%d %d", &a, &b)) {
		if (b<-1000)return 0;
		if (b == 0)return 0;
		else if (a == 0 && b == 0) 
		{ 
			printf(" 0 0"); 
			return 0; 
		}
		else if(b!=0)printf(" %d %d", a * b, b - 1);
		b = 0;
	};
	return 0;
}

```

#### 总结
----

### 1011 A+B 和 C (15分)

>给定区间 $\left[-2^{31}, 2^{31}\right]$ 内的 3 个整数 *A*、*B* 和 *C*，请判断 *A*+*B* 是否大于 *C*。
>
>### 输入格式：
>
>输入第 1 行给出正整数 $T (≤10)$，是测试用例的个数。随后给出 $T$ 组测试用例，每组占一行，顺序给出 $A$、$B$ 和 $C$。整数间以空格分隔。
>
>### 输出格式：
>
>对每组测试用例，在一行中输出 `Case #X: true` 如果 $A+B>C$，否则输出 `Case #X: false`，其中 `X` 是测试用例的编号（从 1 开始）。
>
>### 输入样例：
>
>```in
>4
>1 2 3
>2 3 4
>2147483647 0 2147483646
>0 -2147483648 -2147483647
>```
>     
>    ### 输出样例：
>
>```out
>Case #1: false
>Case #2: true
>Case #3: true
>Case #4: false
>```

#### 解题思路



#### 提交代码

```c
#include <stdio.h>

int main() {
	int count;
	int i;
	double a, b, c;
	scanf("%d", &count);
	for (i = 0; i < count; i++)
	{
		scanf("%lf %lf %lf", &a,&b,&c);
		if (a+b>c)printf("Case #%d: true\n", i + 1);
		else printf("Case #%d: false\n", i + 1);
	}
	return 0;
}

```

#### 总结
----

### 1012 数字分类 (20分)

>给定一系列正整数，请按要求对数字进行分类，并输出以下 5 个数字：
>
>- *A*1 = 能被 5 整除的数字中所有偶数的和；
>- *A*2 = 将被 5 除后余 1 的数字按给出顺序进行交错求和，即计算 $n_{1}-n_{2}+n_{3}-n_{4} \cdots$；
>- *A*3 = 被 5 除后余 2 的数字的个数；`
>- *A*4 = 被 5 除后余 3 的数字的平均数，精确到小数点后 1 位；
>- *A*5 = 被 5 除后余 4 的数字中最大数字。
>
>### 输入格式：
>
>每个输入包含 1 个测试用例。每个测试用例先给出一个不超过 1000 的正整数 *N*，随后给出 *N* 个不超过 1000 的待分类的正整数。数字间以空格分隔。
>
>### 输出格式：
>
>对给定的 *N* 个正整数，按题目要求计算 *A*1~*A*5 并在一行中顺序输出。数字间以空格分隔，但行末不得有多余空格。
>
>若其中某一类数字不存在，则在相应位置输出 `N`。
>
>### 输入样例 1：
>
>```in
>13 1 2 3 4 5 6 7 8 9 10 20 16 18 
>```
>
>### 输出样例 1：
>
>```out
>30 11 2 9.7 9    
>```
>
>### 输入样例 2：
>
>```in
>8 1 2 4 5 6 7 9 16  
>```
>
>### 输出样例 2：
>
>```out
>N 11 2 N 9
>```

#### 解题思路

https://www.jianshu.com/p/ee6cee93f614

#### 提交代码

```c
#include <stdio.h>

int main() {
    int N, x;
    int A1 = 0, A2 = 0, A3 = 0, A5 = 0;
    double A4 = 0.0;

    while (scanf("%d", &N) != EOF) {
        int i = 1, j = 0, A2_judge = 0;//这几个数字一定要放在括号外面不然每次运行都不一样
        while (N--) {
            scanf("%d", &x);
            if (x % 5 == 0 && x % 2 == 0) {
                A1 = A1 + x;
            }

            if (x % 5 == 1) {
                A2 = A2 + i * x;
                i = i * -1;
                A2_judge++;//A2有种比较特殊的情况就是所有的数字相加等于0
            }
            if (x % 5 == 2) {
                A3++;
            }
            if (x % 5 == 3) {
                A4 = x + A4;
                j++;
            }
            if (x % 5 == 4) {
                if (A5 < x) A5 = x;
            }
        }

        if (A1 == 0) printf("N "); else printf("%d ", A1);
        if (A2_judge == 0) printf("N "); else printf("%d ", A2);
        if (A3 == 0) printf("N "); else printf("%d ", A3);
        if (j == 0) printf("N "); else printf("%.1f ", A4 / j);
        if (A5 == 0) printf("N"); else printf("%d", A5);
        printf("\n");
    }
    return 0;
}



```

#### 总结
----

### 1013 数素数 (20分)

>令 $P_{i}$ 表示第 $i$ 个素数。现任给两个正整数$M \leq N \leq 10^{4}$，请输出 $P_{M}$ 到$P_{N}$ 的所有素数。
>
>### 输入格式：
>
>输入在一行中给出 $M$ 和 $N$，其间以空格分隔。
>
>### 输出格式：
>
>输出从 $P_{M}$到  $P_{N}$ 的所有素数，每 10 个数字占 1 行，其间以空格分隔，但行末不得有多余空格。
>
>### 输入样例：
>
>```in
>5 27   
>```
>
>### 输出样例：
>
>```out
>11 13 17 19 23 29 31 37 41 43
>47 53 59 61 67 71 73 79 83 89
>97 101 103
>```

#### 解题思路



#### 提交代码

```c
#include <stdio.h>
int isPrime(int i);

int main() {
    int M, N; 
    int count=1;
    int n;
    scanf("%d %d", &M, &N);
	n = M;
	do
	{
		if (count % 10 == 1)printf("%d", isPrime(n));
		else printf(" %d", isPrime(n));
		if (count % 10 ==0)printf("\n");
		count++;
		n++;
	} while (n<=N);

    return 0;
}
int isPrime(int i) {
    int flag;
	int count = 0;
	int j;
	int n = 1;
	while (count!=i)
	{
		flag = 1;
		n++;
		for (j = 2; j * j <= n; j++)
		{
			if (n % j == 0) {
				flag = 0;
				break;
			}
		}
		if (flag==1)
		{
			count++;
		}
	}
	return n;

}
```

#### 总结
----

### 1014 福尔摩斯的约会 (20分)

>大侦探福尔摩斯接到一张奇怪的字条：`我们约会吧！ 3485djDkxh4hhGE 2984akDfkkkkggEdsb s&hgsfdk d&Hyscvnm`。大侦探很快就明白了，字条上奇怪的乱码实际上就是约会的时间`星期四 14:04`，因为前面两字符串中第 1 对相同的大写英文字母（大小写有区分）是第 4 个字母 `D`，代表星期四；第 2 对相同的字符是 `E` ，那是第 5 个英文字母，代表一天里的第 14 个钟头（于是一天的 0 点到 23 点由数字 0 到 9、以及大写字母 `A` 到 `N` 表示）；后面两字符串第 1 对相同的英文字母 `s` 出现在第 4 个位置（从 0 开始计数）上，代表第 4 分钟。现给定两对字符串，请帮助福尔摩斯解码得到约会的时间。
>
>### 输入格式：
>
>输入在 4 行中分别给出 4 个非空、不包含空格、且长度不超过 60 的字符串。
>
>### 输出格式：
>
>在一行中输出约会的时间，格式为 `DAY HH:MM`，其中 `DAY` 是某星期的 3 字符缩写，即 `MON` 表示星期一，`TUE` 表示星期二，`WED` 表示星期三，`THU` 表示星期四，`FRI` 表示星期五，`SAT` 表示星期六，`SUN` 表示星期日。题目输入保证每个测试存在唯一解。
>
>### 输入样例：
>
>```in
>3485djDkxh4hhGE 
>2984akDfkkkkggEdsb 
>s&hgsfdk 
>d&Hyscvnm  
>```
>
>### 输出样例：
>
>```out
>THU 14:04
>```

#### 解题思路



#### 提交代码

```c

```

#### 总结
----

### 1015 德才论 (25分)

>宋代史学家司马光在《资治通鉴》中有一段著名的“德才论”：“是故才德全尽谓之圣人，才德兼亡谓之愚人，德胜才谓之君子，才胜德谓之小人。凡取人之术，苟不得圣人，君子而与之，与其得小人，不若得愚人。”
>
>现给出一批考生的德才分数，请根据司马光的理论给出录取排名。
>
>### 输入格式：
>
>输入第一行给出 3 个正整数，分别为：*N*（≤105），即考生总数；*L*（≥60），为录取最低分数线，即德分和才分均不低于 *L* 的考生才有资格被考虑录取；*H*（<100），为优先录取线——德分和才分均不低于此线的被定义为“才德全尽”，此类考生按德才总分从高到低排序；才分不到但德分到线的一类考生属于“德胜才”，也按总分排序，但排在第一类考生之后；德才分均低于 *H*，但是德分不低于才分的考生属于“才德兼亡”但尚有“德胜才”者，按总分排序，但排在第二类考生之后；其他达到最低线 *L* 的考生也按总分排序，但排在第三类考生之后。
>
>随后 *N* 行，每行给出一位考生的信息，包括：`准考证号 德分 才分`，其中`准考证号`为 8 位整数，德才分为区间 [0, 100] 内的整数。数字间以空格分隔。
>
>### 输出格式：
>
>输出第一行首先给出达到最低分数线的考生人数 *M*，随后 *M* 行，每行按照输入格式输出一位考生的信息，考生按输入中说明的规则从高到低排序。当某类考生中有多人总分相同时，按其德分降序排列；若德分也并列，则按准考证号的升序输出。
>
>### 输入样例：
>
>```in
>14 60 80
>10000001 64 90
>10000002 90 60
>10000011 85 80
>10000003 85 80
>10000004 80 85
>10000005 82 77
>10000006 83 76
>10000007 90 78
>10000008 75 79
>10000009 59 90
>10000010 88 45
>10000012 80 100
>10000013 90 99
>10000014 66 60   
>```
>
>### 输出样例：
>
>```out
>12
>10000013 90 99
>10000012 80 100
>10000003 85 80
>10000011 85 80
>10000004 80 85
>10000007 90 78
>10000006 83 76
>10000005 82 77
>10000002 90 60
>10000014 66 60
>10000008 75 79
>10000001 64 90
>```

#### 解题思路



#### 提交代码

```c

```

#### 总结
----

### 1016 部分A+B (15分)

>正整数 *A* 的“*D**A*（为 1 位整数）部分”定义为由 *A* 中所有 *D**A* 组成的新整数 *P**A*。例如：给定 *A*=3862767，*D**A*=6，则 *A* 的“6 部分”*P**A* 是 66，因为 *A* 中有 2 个 6。
>
>现给定 *A*、*D**A*、*B*、*D**B*，请编写程序计算 *P**A*+*P**B*。
>
>### 输入格式：
>
>输入在一行中依次给出 *A*、*D**A*、*B*、*D**B*，中间以空格分隔，其中 0<*A*,*B*<1010。
>
>### 输出格式：
>
>在一行中输出 *P**A*+*P**B* 的值。
>
>### 输入样例 1：
>
>```in
>3862767 6 13530293 3 
>```
>
>### 输出样例 1：
>
>```out
>399  
>```
>
>### 输入样例 2：
>
>```in
>3862767 1 13530293 8  
>```
>
>### 输出样例 2：
>
>```out
>0
>```

#### 解题思路



#### 提交代码

```c

```

#### 总结
----

### 1017 A除以B (20分)

>本题要求计算 *A*/*B*，其中 *A* 是不超过 1000 位的正整数，*B* 是 1 位正整数。你需要输出商数 *Q* 和余数 *R*，使得 *A*=*B*×*Q*+*R* 成立。
>
>### 输入格式：
>
>输入在一行中依次给出 *A* 和 *B*，中间以 1 空格分隔。
>
>### 输出格式：
>
>在一行中依次输出 *Q* 和 *R*，中间以 1 空格分隔。
>
>### 输入样例：
>
>```in
>123456789050987654321 7  
>```
>
>### 输出样例：
>
>```out
>17636684150141093474 3
>```

#### 解题思路



#### 提交代码

```c

```

#### 总结
----

### 标题

>
>
>

#### 解题思路



#### 提交代码

```c

```

#### 总结
----

### 标题

>
>
>

#### 解题思路



#### 提交代码

```c

```

#### 总结
----

### 标题

>
>
>

#### 解题思路



#### 提交代码

```c

```

#### 总结
----